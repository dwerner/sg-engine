
pub mod vertex;
use self::vertex::Vertex;

use vulkano_win;
use vulkano;
use cgmath;
use winit;

use vulkano_win::VkSurfaceBuild;
use vulkano_win::Window;
use vulkano::buffer::BufferUsage;
use vulkano::buffer::CpuAccessibleBuffer;
use vulkano::command_buffer::DynamicState;
use vulkano::command_buffer::AutoCommandBufferBuilder;
use vulkano::command_buffer::CommandBufferBuilder;
use vulkano::device::Device;
use vulkano::framebuffer::Framebuffer;
use vulkano::framebuffer::Subpass;
use vulkano::instance::Instance;
use vulkano::pipeline::GraphicsPipeline;
use vulkano::pipeline::GraphicsPipelineParams;
use vulkano::pipeline::blend::Blend;
use vulkano::pipeline::depth_stencil::DepthStencil;
use vulkano::pipeline::input_assembly::InputAssembly;
use vulkano::pipeline::multisample::Multisample;
use vulkano::pipeline::vertex::SingleBufferDefinition;
use vulkano::pipeline::viewport::ViewportsState;
use vulkano::pipeline::viewport::Viewport;
use vulkano::pipeline::viewport::Scissor;
use vulkano::swapchain::SurfaceTransform;
use vulkano::swapchain::Swapchain;
use vulkano::pipeline::input_assembly::PrimitiveTopology;
use vulkano::image::{
    SwapchainImage,
    ImageViewAccess,
    Image
};

use vulkano::device::QueuesIter;
use vulkano::device::Queue;
use vulkano::sync::GpuFuture;
use vulkano::descriptor::pipeline_layout::{
    PipelineLayout,
    PipelineLayoutDescUnion,
};
use vulkano::framebuffer::{
    RenderPassAbstract,
    FramebufferAbstract
};

use std::sync::Arc;
use std::time::Duration;

use std::collections::VecDeque;
use std::collections::hash_map::HashMap;

use ::renderer::utils::fps;

use game_state::{Renderer, Renderable};
use game_state::tree::{ BreadthFirstIterator };
use game_state::state::SceneGraph;

//TODO: compile these elsewhere, at build time?
// These shaders are a PITA, generated by build.rs, dependent on OUT_DIR... *barf
// More importantly, these are actually compiled SPIR-V, ignore the glsl file extension on them
mod vs { include!{concat!(env!("OUT_DIR"), "/shaders/assets/shaders/triangle_vs.glsl") }}
mod fs { include!{concat!(env!("OUT_DIR"), "/shaders/assets/shaders/triangle_fs.glsl") }}

pub struct BufferItem {
    pub vertices: Arc<CpuAccessibleBuffer<[Vertex]>>,
    pub indices: Arc<CpuAccessibleBuffer<[u16]>>
}

pub struct VulkanRenderer {
	instance: Arc<Instance>,
	window: Window,
	device: Arc<Device>,
	queues: QueuesIter,
	queue: Arc<Queue>,
	swapchain: Arc<Swapchain>,
	images: Vec<Arc<SwapchainImage>>,
	submissions: Vec<Box<GpuFuture>>,
	pipeline: Arc<
        GraphicsPipeline<
            SingleBufferDefinition<Vertex>,
            PipelineLayout<PipelineLayoutDescUnion<::renderer::vulkan::vs::Layout, ::renderer::vulkan::fs::Layout>>,
            Arc<RenderPassAbstract+Send+Sync>
        >
    >,
	framebuffers: Vec<Arc<FramebufferAbstract + Send + Sync>>,//Vec<Arc<Framebuffer<render_pass::CustomRenderPass>>>,
	fps: fps::FPS,

    renderpass: Arc<RenderPassAbstract + Send + Sync>,
    pipeline_set: Arc<
        vulkano::descriptor::descriptor_set::SimpleDescriptorSet<
            ((),
             vulkano::descriptor::descriptor_set::SimpleDescriptorSetBuf<
                 Arc<
                     vulkano::buffer::CpuAccessibleBuffer<
                        ::renderer::vulkan::vs::ty::Data
                    >
                 >
             >
            )
        >
    >,//Arc<pipeline_layout::set0::Set>,

    uniform_buffer: Arc<CpuAccessibleBuffer<::renderer::vulkan::vs::ty::Data>>,
    render_layer_queue: VecDeque<Arc<SceneGraph>>,
    buffer_cache: HashMap<usize, BufferItem>,
    debug_world_rotation: f32,
}

pub enum DrawMode {
    Wireframe,
    Points,
    Colored
}

impl VulkanRenderer {
	pub fn new(title: &str, h: u32, w: u32, draw_mode: DrawMode) -> Self {

        let polygonmode = match draw_mode {
            DrawMode::Colored => PolygonMode::Fill,
            DrawMode::Points  => PolygonMode::Point,
            DrawMode::Wireframe => PolygonMode::Line
        };

		// Vulkan
		let instance = {
			let extensions = vulkano_win::required_extensions();
			Instance::new(None, &extensions, None).expect("Failed to create Vulkan instance.")
		};

		let physical = vulkano::instance::PhysicalDevice::enumerate(&instance)
			.next().expect("No device available.");

		let window = winit::WindowBuilder::new()
            .with_title(title)
            .with_dimensions(h,w)
            .build_vk_surface(&instance).unwrap();

		let queue = physical.queue_families().find(|q| {
			q.supports_graphics() && window.surface().is_supported(q).unwrap_or(false)
		}).expect("Couldn't find a graphical queue family.");

		let (device, mut queues) = {
			let device_ext = vulkano::device::DeviceExtensions {
				khr_swapchain: true,
				.. vulkano::device::DeviceExtensions::none()
			};

			Device::new(&physical, physical.supported_features(), &device_ext,
				[(queue, 0.5)].iter().cloned()
			).expect("Failed to create device.")
		};

		let queue = queues.next().unwrap();

		let (swapchain, images): (Arc<Swapchain>, Vec<Arc<SwapchainImage>>) = {
			let caps = window.surface().get_capabilities(&physical).expect("Failed to get surface capabilities");
			let dimensions = caps.current_extent.unwrap_or([1280, 800]);
			let present = caps.present_modes.iter().next().unwrap();
			let alpha = caps.supported_composite_alpha.iter().next().unwrap();
			let format = caps.supported_formats[0].0;
			Swapchain::new(
				&device,
				&window.surface(),
				2,
				format,
				dimensions,
				1,
				&caps.supported_usage_flags,
				&queue,
				SurfaceTransform::Identity,
				alpha,
				present,
				true,
				None
			).expect("Failed to create swapchain.")
		};

		let vs = vs::Shader::load(&device).expect("failed to create vs shader module");
		let fs = fs::Shader::load(&device).expect("failed to create fs shader module");

        let proj = cgmath::perspective(
            cgmath::Rad(::std::f32::consts::FRAC_PI_2),
            {
               let d = Image::dimensions(&images[0]);
               d.width() as f32 / d.height() as f32
            },
            0.01,
            100.0 // depth used for culling!
        );

        // Vulkan uses right-handed coordinates, y positive is down
        let view = cgmath::Matrix4::look_at(
            cgmath::Point3::new(0.0, 0.0, -4.0),   // eye
            cgmath::Point3::new(0.0, 5.5, 0.0),  // center
            cgmath::Vector3::new(0.0, 1.0, 0.0)  // up
        );

        let scale = cgmath::Matrix4::from_scale(1.0);

        let depth_buffer = Image::access(vulkano::image::attachment::AttachmentImage::transient(
            &device,
            SwapchainImage::dimensions(&images[0]),
            vulkano::format::D16Unorm
        ).unwrap());

        let uniform_buffer = CpuAccessibleBuffer::<vs::ty::Data>::from_data(
            &device,
            &vulkano::buffer::BufferUsage::all(),
            Some(queue.family()),
            vs::ty::Data {
                world : <cgmath::Matrix4<f32> as cgmath::SquareMatrix>::identity().into(),
                view : (view * scale).into(),
                proj : proj.into(),
            }).expect("failed to create buffer");

        //let descriptor_pool = vulkano::descriptor::descriptor_set::DescriptorPool::new(&device);

        let renderpass = single_pass_renderpass!(device.clone(),
                attachments: {
                    color: {
                        load: Clear,
                        store: Store,
                        format: Image::format(&images[0]),
                        samples: 1,
                    },
                    depth: {
                        load: Clear,
                        store: DontCare,
                        format: vulkano::image::ImageAccess::format(&depth_buffer),
                        samples: 1,
                    }
                },
                pass: {
                    color: [color],
                    depth_stencil: {depth}
                }
            ).unwrap();


        let renderpass_arc = Arc::new(renderpass); //as Arc<RenderPassAbstract + Send + Sync>;
        let depth_buffer = Arc::new(depth_buffer);

        let framebuffers = images.iter().map(|image| {
            let attachments = renderpass_arc.desc().start_attachments()
                .color(image.clone()).depth(depth_buffer.clone());
            let dimensions = [Image::dimensions(image).width(), Image::dimensions(image).height(), 1];
            Framebuffer::new(
                renderpass_arc.clone(),
                dimensions,
                vec![ // because we are using RenderPassAbstract, we have to pass the Vec<Arc<ImageView + Send + Sync>>
                    image.clone() as Arc<ImageViewAccess + Send + Sync>,
                    depth_buffer.clone() as Arc<ImageViewAccess + Send + Sync>
                ]
            ).unwrap() as Arc<FramebufferAbstract + Send + Sync>
        }).collect::<Vec<_>>();

        use vulkano::pipeline::raster::{
            Rasterization,
            PolygonMode,
            CullMode,
            FrontFace,
            DepthBiasControl
        };

        let mut raster = Rasterization::default();
        raster.cull_mode = CullMode::Front;
        raster.polygon_mode = polygonmode;
        //raster.depth_clamp = true;
        raster.front_face = FrontFace::CounterClockwise;
        raster.line_width = Some(2.0);
        //raster.depth_bias = DepthBiasControl::Dynamic;

		let pipeline = Arc::new(GraphicsPipeline::new(&device, GraphicsPipelineParams {
			vertex_input: SingleBufferDefinition::new(),
			vertex_shader: vs.main_entry_point(),
			input_assembly: InputAssembly {
				topology: PrimitiveTopology::TriangleList,
				primitive_restart_enable: false,
			},
			tessellation: None,
			geometry_shader: None, //&geometry_shader,
			viewport: ViewportsState::Fixed {
				data: vec![(
					Viewport {
						origin: [0.0, 0.0],
						depth_range: 0.0 .. 1.0,
						dimensions: [Image::dimensions(&images[0]).width() as f32,
						Image::dimensions(&images[0]).height() as f32],
					},
					Scissor::irrelevant()
				)],
			},
			raster: raster,
			multisample: Multisample::disabled(),
			fragment_shader: fs.main_entry_point(),
			depth_stencil: DepthStencil::disabled(),
			blend: Blend::pass_through(),
			render_pass: Subpass::from(renderpass_arc.clone() as Arc<RenderPassAbstract + Send + Sync>, 0).unwrap(),
		}).unwrap());

        let pipeline_set = Arc::new(simple_descriptor_set!(pipeline.clone(), 0, {
            uniforms: uniform_buffer.clone()
        }));

        let depth_buffer = vulkano::image::attachment::AttachmentImage::transient(
            &device,
            SwapchainImage::dimensions(&images[0]),
            vulkano::format::D16Unorm
        ).unwrap();


		let submissions: Vec<Box<GpuFuture>> = Vec::new();

		VulkanRenderer {
            instance: instance.clone(),
            window: window,
			device: device,
            queues: queues,
			queue: queue,
			swapchain: swapchain,
            images: images,
			submissions: submissions,
			pipeline: pipeline,
			framebuffers: framebuffers,
            renderpass: renderpass_arc as Arc<RenderPassAbstract + Send + Sync>,
            pipeline_set: pipeline_set,

            fps: fps::FPS::new(),
            uniform_buffer: uniform_buffer,
            render_layer_queue: VecDeque::new(),
            buffer_cache: HashMap::new(),
            debug_world_rotation: 0f32,
		}

	}


	pub fn instance(&self) -> Arc<Instance> {
		self.instance.clone()
	}

	pub fn queues(&mut self) -> &mut QueuesIter {
		&mut self.queues
	}

	pub fn images(&mut self) -> &Vec<Arc<SwapchainImage>> {
		&mut self.images
	}

	pub fn window(&self) -> &vulkano_win::Window {
		&self.window
	}

	pub fn native_window(&self) -> &winit::Window {
		&self.window.window()
	}

    #[inline]
    pub fn insert_buffer(&mut self, id: usize, vertices: &Vec<Vertex>, indices: &Vec<u16>) {
        self.buffer_cache.insert(id,
            BufferItem{
                vertices: CpuAccessibleBuffer::from_iter(
                    &self.device,
                    &BufferUsage::all(),
                    Some(self.queue.family()),
                    vertices.iter().cloned()
                ).expect("Unable to create buffer"),
                indices: CpuAccessibleBuffer::from_iter(
                    &self.device,
                    &BufferUsage::all(),
                    Some(self.queue.family()),
                    indices.iter().cloned()
                ).expect("Unable to create buffer")
            }
        );
    }

    fn render(&mut self) {

        while self.submissions.len() >= 4 {
            self.submissions.remove(0);
        }

        let (image_num, future) = self.swapchain.acquire_next_image(Duration::new(1, 0)).unwrap();

        let mut cmd_buffer_build = AutoCommandBufferBuilder::new(self.device.clone(), self.queue.family()).unwrap() // catch oom error here
            .begin_render_pass(
                self.framebuffers[image_num].clone(), false,
                //
                vec![
                    vulkano::format::ClearValue::from([0.0,0.0,0.0,1.0]),
                    vulkano::format::ClearValue::Depth(1.0)
                ]
            ).expect("unable to begin renderpass");

        // TODO: do away with this renderable queue
        loop {
            self.debug_world_rotation += 0.01;
            match self.render_layer_queue.pop_front() {
                Some(next_layer) => {

                    // TODO: updating the world matrices from the parent * child's local matrix
                    let mut iterator = BreadthFirstIterator::new(next_layer.root.clone());
                    for (id, rc) in iterator {
                        let mut node = &mut rc.borrow_mut();

                        let model_mat = node.data.get_model_matrix().clone();
                        let rotation = cgmath::Matrix4::from_angle_y(cgmath::Rad(self.debug_world_rotation));
                        let rot_model = model_mat * rotation;
                        match node.parent() {
                            Some(parent) => {
                                let ref parent_model = parent.borrow().data;
                                let global_mat = parent_model.get_world_matrix() * rot_model;
                                node.data.set_world_matrix(global_mat);
                            },
                            None => {
                                node.data.set_world_matrix(rot_model);
                            }
                        }

                        let mesh = node.data.get_mesh();

                        if !self.buffer_cache.contains_key(&(node.data.id as usize)) {
                            let vertices: Vec<Vertex> = mesh.vertices.iter().map(|x| Vertex::from(*x)).collect();
                            self.insert_buffer(
                                node.data.id as usize,
                                &vertices,
                                &mesh.indices
                            );
                        }

                        let (v,i) = {
                            let &BufferItem {
                                vertices: ref vert_buffer,
                                indices: ref index_buffer
                            } = self.buffer_cache.get(&(node.data.id as usize)).unwrap();
                            (vert_buffer.clone(), index_buffer.clone())
                        };

                        let push = vs::ty::PushConstants {
                            model: node.data.get_world_matrix().clone().into()
                        };
                        // begin the command buffer
                        cmd_buffer_build = cmd_buffer_build.draw_indexed(
                                self.pipeline.clone(),
                                DynamicState::none(),
                                v.clone(),
                                i.clone(),
                                self.pipeline_set.clone(),
                                push
                        ).expect("Unable to add command");

                    }
                },
                None => break
            }
        }

        let cmd_buffer_build = cmd_buffer_build.end_render_pass();
        //println!("finalizing command buffer");
        let cmd_buffer = cmd_buffer_build.expect("unable to end renderpass").build().unwrap();

        let future = future
            .then_execute(self.queue.clone(), cmd_buffer)
            .then_swapchain_present(self.queue.clone(), self.swapchain.clone(), image_num)
            .then_signal_fence();

        future.flush().unwrap();

        self.submissions.push(Box::new(future) as Box<_>);

        self.fps.update();
    }

    #[allow(dead_code)]
    fn fps(&self) -> f32 {
        self.fps.get()
    }

}

impl Renderer for VulkanRenderer {
    fn load(&mut self) {

    }

    fn unload(&mut self) {
        self.buffer_cache.clear();
    }

    fn queue_render_layer(&mut self, layer: Arc<SceneGraph>) {
        self.render_layer_queue.push_back(layer);
    }

    fn present(&mut self) {
        self.render();
    }
}

